## chap 1. HTTP HTTPS, HTTP Method

책을 비롯한 기존 인쇄물의 경우 한 문서에서 다른 문서로 넘어가는 과정은 모두 선형적으로 이루어진다.
가령 어떤 책에 7장에 있는 글을 보고 싶다면, 빠르게 1장에서 7장까지 이동하며 원하는 페이지로 선형적으로 이동한다.

반면에, 하이퍼텍스트는 하이퍼링크를 통해 각 텍스트를 비선형적으로 연결한다.
다시 말하자면, 웹 상에서 어떤 문서를 탐색하는 일은 책갈피를 넘기듯이 탐색하는 것이 아니라
A 에서 B로 이동하듯이 탐색하게 되는 것이다.

이때 하이퍼 링크를 통하여 전송되는 데이터가 HyperText이며
이러한 HyperText로부터 파생된 마크업 언어가 HTML이다.

HTTP는 이러한 문서들을 전송하기 위한 규약이다.
웹상에서 보통 사용자라고 일컫는 클라이언트와 서버 간에 요청/응답으로 정보를 주고받을 수 있도록 약속한 프로토콜이다.

이러한 약속 때문에 우리는 국가와 언어의 장벽을 뛰어 넘어서 데이터를 주고 받을 수 있다.

**HTTPS(HyperText Transfer Protocol Secure)** : HTTP에서 보안을 높인 버전으로
SSL(Secure Socket Layer)이나 TLS(Transport Layer Security) 프로토콜을 사용하여 보안성을 높였다는 특징이 있다.

**HTTP Method** : 클라이언트가 서버에 요청을 보낼 때 사용하는 방식으로
GET, POST, PUT, DELETE 등이 있다.

## chapter 2. TCP와 UDP

### 2-1. TCP(Transmission Control Protocol)

- 인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
- 연결 지향 방식이다.
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식.

### [ TCP 서버의 특징 ]

- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)

Q) 패킷(Packet)이란?
인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각들로 나누어 전송을 하는데 이때, 이 조각을 패킷이라고 함.

Q) TCP는 패킷을 어떻게 추적 및 관리하나?
위에서 데이터는 패킷단위로 나누어 같은 목적지(IP계층)으로 전송된다고 설명하였습니다. 예를 들어 한줄로 서야하는 A,B,C라는 사람(패킷)들이 서울(발신지)에서 출발하여 부산(수신지)으로 간다고 합시다. 그런데 A,B,C가 순차적으로 가는 상황에서 B가 길을 잘못 들어서 분실되었다고 합시다. 하지만 목적지에서는 A,B,C가 모두 필요한지 모르고 A,C만 보고 다 왔다고 착각할 수 있습니다. 그렇기 때문에 A,,B,C라는 패킷에 1,2,3이라는 번호를 부여하여 패킷의 분실 확인과 같은 처리를 하여 목적지
에서 재조립을 합니다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립을 할 수 있습니다.

### 2-2 UDP(User Datagram Protocol)

- 데이터를 데이터그램 단위로 처리하는 프로토콜
- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다

### 2-3 TCP 3way / 4way handshake

**TCP 3 Way Handshake** : TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

Client > Server : **TCP SYN**
Server > Client : **TCP SYN, ACK**
Client > Server : **TCP ACK**

여기서 SYN은 'synchronize sequence numbers', 그리고 ACK는'acknowledgment' 의 약자이다.
이러한 절차는 TCP 접속을 성공적으로 성립하기 위하여 반드시 필요하다.

**TCP의 3-way Handshaking 역할**

- 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에
- 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.
- 양쪽 모두 상대편에 대한 초기 순차일련변호를 얻을 수 있도록 한다.

**4-Way handshake** : 세션을 종료하기 위해 수행되는 절차

**[STEP 1]**

- 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 **A클라이언트는 FIN-WAIT** 상태가 된다.

**[STEP 2]**

- B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태 **B서버의 CLOSE_WAIT**상태다.

**[STEP 3]**
연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 **LAST-ACK**이다.

**[STEP 4]**
클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.
**A클라이언트의 상태가 FIN-WAIT ->\*\***TIME-WAIT\*\* 으로 변경된다.

그런데 만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까?

Client에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop되고 데이터는 유실될 것입니다.

**A클라이언트**는 이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 **"\*\***TIME_WAIT\***\*"** 라고 합니다. 일정시간이 지나면, 세션을 만료하고 연결을 종료시키며, **"CLOSE"** 상태로 변화합니다.

## chapter 3. [www.naver.com]에 접속할 떄 생기는 일

1.  사용자가 브라우저에 도메인 네임([www.naver.com)]을입력한다.
2.  사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
3.  페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다.
4.  이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
5.  검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.
6.  도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.

## chapter 4. OSI 7 계층이란?

OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다.

**OSI 7 계층을 나눈이유는?**
계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다.
흐름을 한눈에 알아보기 쉽고, 사람들이 이해하기 쉽고,
7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건들이지 않고도 이상이 생긴 단계만 고칠 수 있기 때문이다.

**1계층 - 물리계층(Physical Layer)**

- 이 계층에서는 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하게 된다.
- 이 계층에서 사용되는 통신 단위는 비트이며 이것은 1과 0으로 나타내어지는, 즉 전기적으로 On, Off 상태라고 생각하면 된다.
- 이 계층에서는 단지 데이터를 전달만 할뿐 전송하려는(또는 받으려는)**데이터가 무엇인지, 어떤 에러가 있는지 등에는 전혀 신경 쓰지 않는다.**
- 단지 데이터 전기적인 신호로 변환해서 주고받는 기능만 할 뿐이다. 이 계층에 속하는 대표적인 장비는 **통신 케이블, 리피터, 허브**등이 있다.

**2계층 - 데이터 링크계층(DataLink Layer)**

- 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **정보의 전달을 수행**할 수 있도록 도와주는 역할을 한다.
- 따라서 통신에서의 오류도 찾아주고 재전송도 하는 기능을 가지고 있는 것이다.
- 이 계층에서는 **맥 주소를 가지고 통신**하게 된다.
- 이 계층에서 전송되는 단위를 프레임이라고 하고, 대표적인 장비로는 **브리지, 스위치** 등이 있다.(여기서 MAC주소를 사용한다.)

-> **브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함**.

- 데이터 링크 계층(Data link layer)은 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층으로
- CRC 기반의 오류 제어와 흐름 제어가 필요하다. 네트워크 위의 개체들 간 데이터를 전달하고,
- 물리 계층에서 발생할 수 있는 오류를 찾아 내고, 수정하는 데 필요한 기능적, 절차적 수단을 제공한다.
- 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다.
- 주소 체계는 계층이 없는 단일 구조이다. 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.
- 이 외에도 HDLC나 ADCCP 같은 포인트 투 포인트(point-to-point) 프로토콜이나
- 패킷 스위칭 네트워크나 LLC, ALOHA 같은 근거리 네트워크용 프로토콜이 있다.
- 네트워크 브릿지나 스위치 등이 이 계층에서 동작하며, 직접 이어진 곳에만 연결할 수 있다.

**3계층 - 네트워크 계층(Network Layer)**
이 계층에서 가장 중요한 기능은 **데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)**이다.
여기에 사용되는 프로토콜의 종류도 다양하고, 라우팅하는 기술도 다양하다.

이 계층은 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 역할이다.
이 계층의 대표적인 장비는 라우터 이며, 요즘은 2계층의 장비 중 스위치라는 장비에 라우팅 기능을 장착한 Layer 3 스위치도 있다.

(여기서 IP주소를 사용한다.)

네트워크 계층(Network layer)은 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로
다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한
기능적, 절차적 수단을 제공한다.

네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션(segmentation/desegmentation), 오류 제어, 인터네트워킹(Internetworking) 등을 수행한다.

라우터가 이 계층에서 동작하고 이 계층에서 동작하는 스위치도 있다.
데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.

서브네트의 최상위 계층으로 경로를 설정하고, 청구 정보를 관리한다. 개방형 시스템들의 사이에서 네트워크 연결을 설정, 유지, 해제하는 기능을 부여하고, 전송 계층 사이에 네트워크 서비스 데이터 유닛(NSDU : Network Service Data Unit)을 교환하는 기능을 제공한다.

**4계층 - 전송 계층(Transport Layer)**

통신을 활성화하기 위한 계층이다. 보통 TCP프로토콜을 이용하며, 포트를 열어서 응용프로그램들이 전송을 할 수 있게 한다.
만약 데이터가 왔다면 4계층에서 해당 데이터를 하나로 합쳐서 5계층에 던져 준다.
단대단 오류제어 및 흐름제어 이 계층 까지는 물리적인 계층에 속한다.(TCP/UDP프로토콜을 사용한다.)

전송 계층(Transport layer)은 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어,
상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
시퀀스 넘버 기반의 오류 제어 방식을 사용한다.

전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful),
**연결 기반(connection oriented)**이다.

이는 **전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것**을 뜻한다.
가장 잘 알려진 전송 계층의 예는 TCP이다.

종단간(end-to-end) 통신을 다루는 최하위 계층으로 종단간 신뢰성 있고 효율적인 데이터를 전송하며,
기능은 오류검출 및 복구와 흐름제어, 중복검사 등을 수행한다.

**5계층 -세션 계층(Session Layer)**
**데이터가 통신하기 위한 논리적인 연결**을 말한다. 통신을 하기위한 대문이라고 보면 된다.
하지만 4계층에서도 연결을 맺고 종료할 수 있기 때문에 우리가 어느 계층에서 통신이 끊어 졌나 판단하기는 한계가 있다.
그러므로 세션 계층은 4 계층과 무관하게 응용 프로그램 관점에서 봐야 한다.
세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능이 있다.

세션 계층(Session layer)은 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.

**동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)**의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.

이 계층은 **TCP/IP 세션을 만들고 없애는 책임**을 진다.

->
통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룬다.
통신을 하기 위한 세션을 확립/유지/중단 (운영체제가 해줌)

**6계층 - 표현 계층(Presentation Layer)**

데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.

표현 계층(Presentation layer)은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

예를 들면, EBCDIC로 인코딩된 문서 파일을 ASCII로 인코딩된 파일로 바꿔 주는 것,

해당 데이터가 TEXT인지, 그림인지, GIF인지 JPG인지의 구분 등이 표현 계층의 몫이다.

-> 사용자의 명령어를 완성및 결과 표현. 포장/압축/암호화

**7계층 - 응용 계층(Application Layer)**

최종 목적지로서 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.
해당 통신 패킷들은 방금 나열한 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나, 메일 프로그램은 프로토콜을
보다 쉽게 사용하게 해주는 응용프로그램이다. 한마디로 모든 통신의 양 끝단은 HTTP와 같은 프로토콜이지 응용프로그램이 아니다.

응용 계층(Application layer)은 응용 프로세스와 직접 관계하여 일반적인 **응용 서비스를 수행**한다.

일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.
응용 서비스의 예로, 가상 터미널(예를 들어, **텔넷**), "Job transfer and Manipulation protocol" (JTM, 표준 ISO/IEC 8832) 등이 있다.

-> 네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O)부분

## chapter 5. DNS

### 5-1. DNS는 무엇인가요?

DNS(Domain Name System)은 사용자가 숫자로 된 인터넷 프로토콜 주소 대신 인터넷 도메인 이름과 검색 가능한 URL을 사용하여 웹사이트에 접속하는 것을 가능하게 합니다. 사용자는 *93.184.216.34*와 같은 IP 주소를 기억하는 대신 _www.example.com_을 검색할 수 있습니다.

DNS의 기반이 되는 기술은 스마트폰에서 주소록이 관리되는 방식에 비유될 수 있습니다. 사용자는 개별 전화 번호를 기억하는 대신 성과 이름으로 쉽게 검색 가능한 주소록 목록에 저장하여 손쉽게 번호를 찾을 수 있습니다.

DNS의 기반이 되는 변환 기술 역시 기업들이 인터넷을 사용하는 방식을 전적으로 정의했습니다. 특히 이러한 기업들이 브랜드 정체성을 형성하고 고객에게 다가가는 경우 그렇습니다. DNS를 사용하지 않으면 고객은 자신이 찾고 있는 웹사이트를 금방 잊을 수 있습니다. IP 주소는 때때로 변경될 수 있지만 도메인 이름은 일관적이며 기억하기가 쉽습니다.

### 5-2. DNS는 어떻게 작동하나요?

퍼블릭 DNS와 프라이빗 DNS를 사용하는 경우를 구분해야 합니다.

- **퍼블릭 DNS:** 일반적으로 인터넷 서비스 제공업체(Internet service provider, ISP)가 기업에 IP 레코드를 제공합니다. 이러한 레코드는 일반 대중에게 제공되며, 사용 중인 디바이스 또는 디바이스에 연결된 [네트워크](https://www.ibm.com/kr-ko/topics/networking) 에 상관없이 누구나 액세스할 수 있습니다.
- **프라이빗 DNS:** 프라이빗 DNS는 회사의 방화벽 뒤에 존재하며 내부 사이트의 레코드만을 보관한다는 점에서 퍼블릭 DNS와 다릅니다. 이 경우 프라이빗 DNS의 범위는 내부 사이트 및 사용되는 서비스의 IP 주소를 기억하는 것으로 제한되며, 프라이빗 네트워크 외부에서 액세스할 수 없습니다.

대부분의 경우 사용자는 호스트 이름을 IP 주소로 변환할 때 퍼블릭 DNS에 의존합니다. 이 프로세스의 작동 방식에 대한 개괄적 설명이 아래에 제시되어 있습니다.

1.  사용자가 도메인 이름 또는 URL(예: _www.example.com_)을 브라우저에 입력합니다. 그러면 일반적으로 로컬 운영 체제나 인터넷 서비스 제공업체가 제공하는 로컬 DNS 서버로 쿼리가 전송됩니다. 클라이언트와 DNS의 사이의 이 중개자는 재귀 확인자라고 합니다. 재귀 확인자는 클라이언트에 대해 쿼리된 네임서버 정보를 요청하거나 수신하도록 설계되었습니다.
2.  재귀 확인자가 쿼리를 요청하면 쿼리가 루트 네임서버로 전달됩니다. 루트 네임서버는 검색된 도메인 이름의 확장자를 기반으로 지시를 내려야 하는 적절한 TLD 네임서버로 응답합니다. 루트 네임서버는 또한 ICANN(Internet Corporation for Assigned Names and Numbers)의 감독을 받습니다. TLD 네임서버는 .com, .net, .edu, .gov와 같은 일반적인 확장자로 끝나는 URL에 대한 모든 정보를 보관합니다.
3.  정기적으로 수행되는 DNS 검색량 때문에 검색 요청을 배치로 묶는 데 재귀 확인자가 사용됩니다. 이러한 배치는 검색 쿼리 기반의 정확한 IP 주소로 권위(authoritative) DNS를 찾습니다. 권위 네임서버는 보통 DNS 조회의 마지막 단계입니다. 재귀 확인자는 TLD 네임서버로부터 응답을 받은 후 클라이언트로 다시 전송되기 위해 IP 주소가 확인되는 권위 네임서버로 이동합니다.

DNS는 인터넷의 핵심 기능을 위해 필수적인 역할을 수행하게 되었으며, 사용자가 리소스 레코드를 통해 IP 주소의 바다를 쉽게 헤엄쳐나가도록 돕습니다. 이러한 필수적 프로세스가 작동하지 않는다면 우리가 매일 온라인으로 사용하는 모든 기능을 지원하는 것이 사실상 불가능할 것입니다. 또한, 메일 서비스, 웹사이트 리디렉션 설정 또는 복잡한 IPv4 및 IPv6 웹 주소 인식과 관련된 우리의 능력이 제한될 것입니다. 그러나 DNS 검색이 놀라운 기술인 이유는 프로세스의 복잡성에 관계없이 클라이언트 측에 영향을 주지 않고 모든 검색 쿼리와 서버 리디렉션이 단 몇 밀리초만에 이루어지기 때문입니다.

## chapter 6. 라우터 / 라우팅 알고리즘

라우팅 알고리즘이란 송신 측에서부터 수신 측 라우터의 네트워크를 통과하는 최적의 경로를 결정하는 알고리즘이다. 그러나 실제로는 여러 가지 이유로 최적의 경로를 결정하지 못할 수 있다.

예를 들어 'A기관은 B기관이 소유한 네트워크가 보낸 패킷을 전달해서는 안된다'와 같은 규칙 등이 존재할 수 있다. 그럼에도 불구하고 최대한 최적의 경로를 결정하는 라우팅 알고리즘은 네트워크 분야에서 매우 중요하다.

라우팅 알고리즘은 중앙 집중형 혹은 분산형인지로 구분할 수 있다.

- 중앙 집중형(global) 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 즉 모든 라우터가 연결 상태와 링크 비용을 알고 있다는 것이다. Link State 알고리즘이 여기에 속하며 주로 다익스트라 알고리즘을 사용한다.
- 분산(decentralized) 라우팅 알고리즘 : 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. 어떤 라우터도 모든 링크 비용에 대한 완전한 정보를 갖고 있지 않지만, 각 라우터는 자신에게 연결된 인접 노드에 대한 링크 비용 정보를 알고 있다. 이후 반복된 계산과 인접 노드와의 정보 교환을 통해 목적지까지의 최소 비용 경로를 계산한다. Distance Vector 알고리즘이 여기 속하며 주로 벨만-포드 알고리즘을 사용한다.

또한 라우팅 알고리즘은 정적 알고리즘과 동적 알고리즘으로 구분할 수 있다.

- 정적 라우팅 알고리즘 : 경로의 변경이 느리고 사람이 직접 링크에 대한 비용을 수정해야 한다. 규모가 큰 네트워크에서 일일이 수정하기 불가능하며 사람이 하기에 역부족이다.
- 동적 라우팅 알고리즘 : 네트워크 트래픽 부하나 topology 변화에 따라 라우터가 자체적으로 경로를 바꾼다. 동적 알고리즘은 주기적으로 topology나 링크 비용의 변경에 직접적으로 응답하는 방식으로 수행된다. 동적 알고리즘은 네트워크 변화에 더 빠르게 대응할 수 있지만 경로의 loop나 경로 진동과 같은 문제에 취약하다.

### Link State 알고리즘(LS알고리즘 : 링크 상태 알고리즘)

LS 알고리즘은 중앙 집중형 알고리즘에 속한다. 즉 모든 라우터(노드)가 모든 링크(간선)의 비용을 알고 있기 때문에 다익스트라 알고리즘을 이용해 최적의 경로를 계산할 수 있다. 한 노드(source node)에서 다른 모든 노드까지의 최적경로를 계산해 routing table에 저장해 놓는다.

### Distance Vector 알고리즘(DV알고리즘 : 거리벡터 알고리즘)

DV 알고리즘은 분산형 알고리즘에 속한다. 즉 각 노드는 자신에게 연결된 이웃의 링크의 비용만 알고 있기 때문에 벨만-포드 알고리즘을 이용해 최적의 경로를 계산할 수 있다. DV 알고리즘은 반복적이고 비 동적이며 분산적이다. 이웃끼리 반복해서 정보를 교환해 최적의 경로를 갱신하는 식이다.

## chapter 7. 웹소켓

### **웹소켓(WebSocket)의 배경**

인터넷이 나오고 HTTP를 통해서 서버로부터 데이터를 가져오기 위해서는 오로지 URL을 통한 요청이 유일한 방법이었습니다. 때문에 아이디 중복 확인과 같은 유효성 검사는 서버로 데이터를 보내는 중간 과정에서 새로운 페이지 요청을 하게 되었습니다.

여기서 발전된 방식이 **Ajax**통신으로 클라이언트에서 XMLHttpRequest 객체를 이용하여 서버에 요청을 보내면 서버가 응답을 하는 방식입니다.

페이지 요청이 아닌 데이터 요청이라 부분적으로 정보를 갱신할 수 있게 됩니다.

**즉,** 사용자의 이벤트로부터 Javascript는 사용자가 작성한 값이 쓰여진 DOM을 읽습니다.

그리고 XMLHttpRequest 객체를 통해 웹서버에 해당 값을 전송하고 웹서버는 요청을 처리하고 XML, Text, JSON 등을 이용하여 XMLHttpRequest 객체에 전송합니다.

그런다음 JavaScript가 해당 응답정보를 DOM에 쓰여집니다.

Ajax를 사용하면 새로운 HTML을 서버로부터 받아야하는 것이 아닌 동일한 페이지의 일부를 수정할 수 있는 가능성이 생기고, 사용자 입장에서는 페이지 이동이 발생되지 않고 페이지 내부 변화만 일어나게 해주므로 그만큼의 자원과 시간을 아낄수 있습니다.

하지만, Ajax도 결국 HTTP를 이용하기 때문에 요청을 보내야 응답이 옵니다.
변경된 데이터를 가져오기 위해서 버튼을 누른다거나 일정 시간 주기로 요청을 보낸다면 번거로울 뿐더러 자원 낭비입니다.
예를 들어 주식에서 기업의 주가를 보려면 매번 버튼을 갱신해서 요청을 하고 서버는 이에 응답을 해주는 것 입니다.
이러한 문제들을 해결하기 위해 웹소켓이 탄생합니다.

### 웹소켓(WebSocket)의 개념

2014년 10월 28일의 HTML5 버전이 나올 때 함께 등장했던 웹소켓은 2016년 11월 1일 HTML5.1버전이 나오고
2017년 12월 14일 HTML5.2버전이 나올때까지 지속적으로 발전해나아갔습니다.

웹소켓은 HTTP와 같이 약속입니다.

Transport protocol의 일종으로 서버와 클라이언트 간의 효율적인 양방향 통신을 실현하기 위한 구조입니다.

웹소켓은 단순한 API로 구성되어있으며, 웹소켓을 이용하면 하나의 HTTP 접속으로 양방향 메시지를 자유롭게 주고받을 수 있습니다.

위 배경에서 웹소켓이 나오기 이전에는 모두 클라이언트의 요청이 없다면, 서버로부터 응답을 받을 수 없는 구조였습니다.

웹소켓은 이러한 문제를 해결하는 새로운 약속이었습니다.

웹소켓에서는 서버와 브라우저 사이에 양방향 소통이 가능합니다. 브라우저는 서버가 직접 보내는 데이터를 받아들일 수 있고, 사용자가 다른 웹사이트로 이동하지 않아도 최신 데이터가 적용된 웹을 볼 수 있게 해줍니다. 웹페이지를 ‘새로고침’하거나 다른 주소로 이동할 때 덧붙인 부가 정보를 통해서만 새로운 데이터를 제공하는 웹서비스 환경의 빗장을 본질적으로 풀어준 셈입니다.

웹에서도 채팅이나 게임, 실시간 주식차트와 같은 실시간이 요구되는 응용프로그램의 개발을 한층 효과적으로 구현할 수 있게 됩니다.

가상화폐의 분산화 기술의 핵심도 WebSocket으로 구현할 수 있습니다.

### **작동원리**

- 서버와 클라이언트간의 웹소켓 연결을 HTTP프로토콜을 통해 이루어집니다.
- 연결이 정상적으로 이루어진다면 서버와 클라이언트 간에 웹소켓 연결(TCP/IP기반)이 이루어지고 일정 시간이 지나면HTTP연결은 자동으로 끊어집니다.
- 기본적으로 웹소켓 API는 아주 간단한 기능들만을 제공하기 때문에 대부분의 경우 SockJS나 Socket.IO같은 오픈 소스 라이브러리를 많이 사용하고 있으며 메시지 포맷 또한 STOMP같은 프로토콜을 같이 이용합니다.

### **문제점**

1.  프로그램 구현에 보다 많은 복잡성을 초래합니다.

- 웹 소켓은 HTTP와 달리 Stateful protocol이기 때문에 서버와 클라이언트 간의 연결을 항상 유지해야 하며 만약 비정상적으로 연결이 끊어졌을때 적절하게 대응해야 한다. 이는 기존의 HTTP 사용시와 비교했을때 코딩의 복잡성을 가중시키는 요인이 될 수 있습니다.

2. 서버와 클라이언트 간의 Socket 연결을 유지하는 것 자체가 비용이 듭니다.

- 특히나 트래픽 양이 많은 서버같은 경우에는 CPU에 큰 부담이 될 수 있습니다.

3. 오래된 버전의 웹 브라우저에서는 지원하지 않습니다. (물론 SockJS 라이브러리 같은 경우에는 Fallback option을 제공하고 있습니다.)

### 대표적인 사용 예

1. 페이스북과 같은 SNS APP
2. LOL 같은 멀티플레이어 Game
3. 위치 기반 APP
4. 증권 거래 정보 사이트 및 APP
5. 화상 채팅 APP
6. 구글 Doc 같이 여러 명이 동시 접속해서 수정할 수 있는 Tool

---

참고사이트

- https://mangkyu.tistory.com/15
- https://bangu4.tistory.com/74
- https://sophia2730.tistory.com/entry/DNS-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-wwwnavercom%EC%9D%84-%EC%B9%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC
- https://shlee0882.tistory.com/110
- https://www.ibm.com/kr-ko/topics/dns
- https://code-lab1.tistory.com/37
- https://choseongho93.tistory.com/266
