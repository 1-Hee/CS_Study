## 1. 데이터베이스 기본 개념

### 1. 데이터베이스를 왜 사용하나요?

- `파일 시스템의 문제를 해결`하기 위해 사용
- 확장성이 좋음: 파일 시스템은 OS 종속적
- 중복 최소화, 보안성, 계속적 변화에 대한 적응: 파일 시스템은 데이터 중복, 비일관성, 검색 등의 문제 존재
- DB는 `원자적 갱신`, `동시성 제어`, `데이터 보호`, `백업 및 회복` 등의 여러 데이터 관리 기능을 통해 데이터를 편하게 관리할 수 있음

과거에 데이터를 관리하기 위해 파일시스템을 이용하였다.

파일 시스템은 데이터를 파일로 관리하여 생성, 삭제, 수정, 검색 기능을 제공하였다.

다음은 도서관에서 보관되어 있는 책과 사용자 정보가 저장된 데이터를 파일시스템 형태로 나타낸 것이다.

![https://blog.kakaocdn.net/dn/miUmm/btryn9qru5Q/knrh8OSbXSW2eClGZWhdbk/img.png](https://blog.kakaocdn.net/dn/miUmm/btryn9qru5Q/knrh8OSbXSW2eClGZWhdbk/img.png)

만약 오른쪽에 저장되어 있는 유저들이 책을 빌려간다면 해당 정보를 아래와 같이 표현할 수 있다.

![https://blog.kakaocdn.net/dn/bsW4Zu/btryp4BWEo2/T3XWpNFVTTp1yWchJCfHX0/img.png](https://blog.kakaocdn.net/dn/bsW4Zu/btryp4BWEo2/T3XWpNFVTTp1yWchJCfHX0/img.png)

위의 파일 시스템에서 응용프로그램별로 파일을 따로 관리하기 때문에 몇 가지 문제점을 확인할 수 있다.

**1. 동일한 데이터가 여러 파일에 중복된다.** 

파일 시스템에서는 프로그램별로 파일을 유지하여 위와같이 여러 파일에 같은 데이터가 중복으로 저장될 수 있다.

즉, **데이터 중복성(Data redundancy)**문제가 발생한다.

또한 데이터가 중복되면 데이터 **일관성(Data consistency)**과 데이터 **무결성(Data Integrity)**을 유지하기 어렵다.

데이터 중복성을 해결하기 위해 아래와 같은 시스템을 생각할 수 있겠지만 다른 문제점들이 있다.

![https://blog.kakaocdn.net/dn/kIlnX/btryn8E3sq7/MT3qiknEIJQGfnuBJToWN1/img.png](https://blog.kakaocdn.net/dn/kIlnX/btryn8E3sq7/MT3qiknEIJQGfnuBJToWN1/img.png)

**2. 응용프로그램이 데이터 파일에 종속적이다.** 

응용프로그램은 파일에 접근하여 데이터를 처리하므로 사용하는 파일의 데이터를 구성하는 방법이나 물리적인 저장 구조에 맞게 작성되어야 한다.

사용중인 파일의 구조를 변경하면 응용프로그램에서도 이와같이 변경해주어야 한다. 

이러한 특징을 데이터 **종속성(Data dependency)**이라 한다.

![https://blog.kakaocdn.net/dn/EjWdw/btryk2ZWetV/cz1CPbABl4E5Sqr1pFKK7k/img.png](https://blog.kakaocdn.net/dn/EjWdw/btryk2ZWetV/cz1CPbABl4E5Sqr1pFKK7k/img.png)

만약 구성원의 나이를 추가한다면 모든 응용프로그램에서 파일에 접근하는 방법을 변경해야 한다.

데이터 형식과 길이가 변경될 때에도 마찬가지이다.

해당 데이터 파일을 사용하는 응용프로그램 숫자가 많아지거나 구조가 자주 변경된다면 이러한 문제점이 부각된다.

**3. 데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.**

파일 시스템에서는 응용프로그램이 사용중인 파일을 다른 응용프로그램이 해당 파일 시스템에 접근하여 사용할 수 있는 동시 공유 기능을 제공하지 않는다. 같은 파일을 여러개 만들어 이 문제를 해결할 수 있지만 데이터 중복성 때문에 더 큰 문제가 발생한다.

더 작은 단위에 대한 접근 통제와 더 구체적인 권한 부여가 가능해야 하며 데이터가 중복된 파일들의 보안을 같은 수준으로 유지하기 어렵다.

파일시스템에서 장애가 일어나면 데이터를 일관된 상태로 회복하기 어렵다.

**4. 파일 시스템을 이용하여 응용 프로그램을 개발하기 어렵다.**

데이터의 구조가 자주 변경되거나 사용자 요구에 맞는 응용프로그램을 개발하는데 어려움이 있다.

파일에서 데이터 읽기, 삽입하기, 삭제하기 등의 데이터 관리 기능을 포함해야 하기 때문이다.

데이터 중복성, 종속성을 해결하고 이러한 시스템을 적용한 것이 **데이터베이스 관리 시스템(DBMS)이다.**

### 2. Database의 특징을 설명하세요.

1. **실시간 접근**(Real-time accessibility)이 가능하다. 

- 데이터베이스는 사용자의 데이터 요구에 실시간으로 응답할 수 있어야 함

2. **계속 변화**(Continuous evolution)한다. 

- 현실의 상태를 끊임없이 정확히 반영해야 의미가 있다.
- DB는 데이터를 생성(Create), 삽입(Insert), 수정(Update), 삭제(Delete)하여 정확한 데이터를 유지해야 함.

3. **동시 공유**(Concurrent sharing)가 가능하다.

- 여러 사용자가 서로 다른 데이터를 동시에 사용하거나 같은 데이터를 통시에 사용할 수 있어야 한다.

4. **내용으로 참조**(Content reference)가 가능하다.

- 찾고자 하는데이터의 내용(값)을 제시하면 조건에 맞는데이터가 다른 위치에 저장되어 있어도 검색할 수 있다.

### 3. Key(키)란 무엇이며 종류에 대해 설명해 주세요.

- **키** : 검색이나 정렬 시 Tuple을 구분할 수 있는 기준이 되는 Attribute.
- **후보키** : 유일성과 최소성을 만족한 키
    - 릴레이션을 구성하는 속성들 중에서 **Tuple을 유일하게 식별할 수 있는 속성들의 부분 집합**을 의미.(기본키로 사용할 수 있는 속성들을 후보키라 한다.)
    - **모든 릴레이션은 반드시 하나 이상의 후보 키를 가져야 한다.**
    - 릴레이션에 있는 모든 튜플에 대해서 **유일성과 최소성을 만족**시켜야 한다.
    - 후보키는 아래 2가지 조건을 만족해야 한다.
        - `유일성` : 해당 키로 하나의 튜플을 식별할수있음
        - `최소성` : 꼭 필요한 속성으로만 이루어짐
- **기본키** : 후보키들 중 선택한 Main key
    - 한 릴레이션에서 **특정 튜플을 유일하게 구별할 수 있는 속성**
    - **Null 값을 가질 수 없다.(개체 무결성의 첫 번째 조건)**
    - **기본 키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.(개체 무결성의 두 번째 조건)**
    - 기본키는 아래 3가지 조건을 만족해야 한다.
        - `유일성` : 기본키를 구성하는 컬럼은 테이블에서 레코드를 식별할 수 있도록 유일해야 한다.
        - `최소성` : 유일성을 만족하는 한도 내에서 최소한의 컬럼(하나 이상)으로 구성되어야 한다.
        - `개체 무결성` : 기본키가 가지고 있는 값의 유일성을 보장받아야 한다.
- **대체키(보조키)** : 후보 키가 두개 이상일 때, 기본 키를 제외한 나머지 후보 키
- **외래키**
    - 참조되는 릴레이션의 `기본 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
    - 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
    - **사용 이유: 테이블을 연결, 중복 방지, 무결성 유지**
        - 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 →  사람과 물건 구매로 테이블을 분리해 중복 제거
    - **외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다**.(참조 무결성의 조건)
- **슈퍼키**
    - **한 릴레이션 내에 있는 속성들의 집합으로 구성된 키**로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타내지 않는다.
    - 릴레이션을 구성하는 모든 튜플에 대해서 **유일성은 만족하지만, 최소성은 만족시키지 못한다.**
    - 예를 들어 [학생] 릴레이션에서는 **학번, 주민번호, 학번+주민번호, 학번+주민번호+성명** 등으로 슈퍼키를 구성할 수 있다. 또한, 여기서 최소성을 만족시키지 못한다는 말은 **학번+주민번호+성명**이 슈퍼키인 경우, 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, **성명** 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못한다. 즉, 뭉쳤을 경우 유일성이 생기고 흩어지면 몇몇 속성들은 독단적으로 유일성이 있는 키로 사용할 수 없다. 이것을 최소성을 만족하지 못한다고 한다.

### 4. 데이터베이스의 무결성 제약조건의 정의와 필요성에 대해 설명해 주세요.

**무결성이란**

- 데이터의 **정확성과 일관성을 유지하고 보증하는** 것

**개체 무결성**

- 기본키로 설정된 컬럼은 고유한 값을 가지며 NULL허용X

**참조 무결성**

- 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 합니다.
- 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없습니다.
- 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는것

**도메인 무결성**

- 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
- ex) 주민등록번호에 알파벳입력되면 도메인 무결성 깨진것

**고유 무결성**

- 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건을 말합니다.
- ex)학생 릴레이션(테이블)에서 테이블 정의시 '이름' 속성에는 중복된 값이 없도록 제한했다면, '이름' 속성에는 중복된 이름이 있어서는 안됩니다.

**NULL 무결성**

- 특정 속성값에 NULL 이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL 값이 올 수 없다는 제약조건을 말합니다.

**키 무결성**

- 한 릴레이션(테이블)에는 최소한 하나의 키가 존재해야 한다는 제약조건을 뜻합니다.

### 5. ON DELETE 참조 무결성 제약조건에서 CASCADE, SET DEFAULT를 사용하면 각각 어떤 현상이 일어나는지 설명해주세요 X

## 2. 데이터베이스 언어 (sql: ddl dml dcl)

### 1. 대표적인 sql종류 3가지에 대해서 설명하고, 종류별 명령어를 아는 만큼 말씀해 주세요.

- 데이터 정의어(DDL): 테이블을 생성하고 변경, 삭제하는 기능을 제공한다.
    - CREATE : Schema, Domain, Table, View, Index를 정의함
    - ALTER : Table에 대한 정의를 변경하는 데 사용함
    - DROP : Schema, Domain,Table, View, Index를 삭제함
- 데이터 조작어(DML): 테이블에 새 데이터를 삽입하거나, 테이블에 저장된 데이터를 수정, 삭제, 검색 하는 기능을 제공한다.
    - SELECT : 테이블에서 조건에 맞는 튜플을 검색함
    - INSERT : 테이블에 새로운 튜플을 삽입함
    - DELETE : 테이블에서 조건에 맞는 튜플을 삭제함
    - UPDATE : 테이블의 조건에 맞는 튜플의 내용을 변경함
- 데이터 제어어(DCL): 보안을 위해 데이터에 대한 접근 및 사용 권한을 사용자별로 부여하거나 취소하는 기능을 하는 언어다. 데이터베이스 관리자(DBA)가 주로 사용한다.
    - COMMIT : 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
    - ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함
    - GRANT : 데이터베이스 사용자에게 사용권한을 부여함
    - REVOKE : 데이터베이스 사용자의 사용권한을 취소함

## 3. RDBMS와 NoSQL

### 1. RDBMS(SQL)에 대해 설명하세요.

**SQL**

- SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색할 수 있다.
- 데이터는 정해진 데이터 스키마(데이터 개체, 속성, 관계,제약조건)에 따라 테이블에 저장
- 데이터는 관계를 통해 여러 테이블에 분산
- 관계를 맺고 있는 데이터가 자주 변경되는 경우 유용함
- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

**장점**

- 명확한 데이터 구조 보장 (정해진 스키마에 따라 데이터를 저장하기 때문에)
- 데이터 중복을 피해, 공간 절약 (각 데이터에 맞게 테이블을 나눠서 저장하기 때문)
- 수직적 확장이 가능하다(단순히 서버의 성능을 향상시키는 것)

**단점**

- 관계로 인한 시스템 복잡도를 고려하여 구조화 해야한다
- 시스템이 복잡하면, query문 복잡, 성능 저하
- 수평적 확장 어려움, 대부분 수직적 확장, 한계에 직면할 수 있다

### 2. NoSQL에 대해 설명하세요.

**NoSQL**

- RDBMS와 달리 다른 형태의 데이터 저장
- 데이터 간의 관계 저장하지않음
- 고정되지 않은 테이블 스키마
- 분산처리 목적으로 나옴
- 반정형(명확한 스키마 없음, 일정 수준의 자유도 허용, NoSQL/JSON 형태의 데이터)/비정형(스키마 없음, 비디오/오디오 등의 멀티미디어 데이터) 데이터에 적합

**장점**

- 스키마가 없어서 유연함, 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할수있음
    - 테이블간의 복잡한 관계를 생각 안해도 된다.
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨
- 대용량/분산형 데이터 저장에 유리
- 읽기가 많고, 변경이 적을때 유리
- 막대한 양의 데이터 다룰때 유리함(수평적 확장 용이)
- 특정 도메인의 문제 해결에 좋음: Key-value, Graph 등 자료 형태가 다양해 특정 분야에서 고성능(소셜 네트워크: 인간 관계는 그래프)
- 데이터를 질의하는 API가 다양

**단점**

- 중복을 계속 업데이트해야 함
- 데이터 구조 결정을 미루게 될 수 있음
- 수정 시 중복된 모든 컬렉션에서 수행해야함
- NoSQL은 SQL보다 제품 지원이 어려움
- 인력 운영 비용이 더 비쌈: 표준화 부족, 질의 언어 다양

**종류** 

- MongoDB, HBASE, Cassandra등

## 4. 인덱스

### 1. 인덱스에 대한 정의와 장점과 단점에 대해 설명하세요.

INDEX 정의

- 추가적인 쓰기와 저장 공간 사용을 통해 검색 속도 향상을 위한 방법
- 검색과 질의를 할 때 테이블 전체를 읽지 않기 때문에 빠르다.
- 칼럼의 값(key)와 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스 정의
- 일반적으로 B+ 트리 자료구조를 사용

INDEX 장점

- 키 값을 기초로 하여 테이블에서 검색과 **정렬 속도를 향상**시킨다.
- 인덱스를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
- 테이블의 기본키는 자동으로 인덱스된다.
- 필드 중에는 데이터 형식 때문에 인덱스 될 수 없는 필드도 있다.
- 여러 필드로 이루어진(다중 필드)인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할 수 있다.
- 참고로 액세스에서 다중 필드 인덱스는 최대 10개의 필드를 포함할 수 있다.

INDEX 단점 

- **인덱스를 만들면 .mdb 파일 크기가 늘어난다**.
- **사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.**
- 인덱스된 필드에서 데이터를 업데이트하거나 **레코드를 추가 또는 삭제할 때 성능이 떨어진다.**
- 인덱스가 데이터베이스 공간을 차지재 추가적인 공간이 필요해진다.(DB의 10% 내외의 공간이 추가로 필요하다.)
- 인덱스를 생성하는데 시간이 많이 소요될 수 있다.
- **데이터 변경 작업이 자주 일어날 경우에 인덱스를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다.**

### 2. 인덱스를 왜 사용하나요

- select문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원과 시간이 소모될 것이다. 이때 도움이 되는게 인덱스이다.
- 자주 조회되는 Column 에 대한 Index Table을 따로 만들어 SELECT 문이 들어왔을 때 Index 테이블에 있는 값들로 결과 값을 조회해 온다.
- Index를 잘 사용한다면 "검색" 연산을 실행했을 때 성능을 올릴 수 있게 된다.

### 3. **Table Full Scan과 Index Range Scan 을 설명하세요**

**Table Full Scan**

- **테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식**
- Table Full Scan는 피해야 한다는 인식이 많지만, 오히려 인덱스를 사용하는 것이 성능을 떨어뜨리는 경우가 더 많음
- 캐시에서 못 찾으면 한 번의 I/O Call로 인접한 수십-수백 개의 블록을 한꺼번에 불러오는 것이 좋음

**Index Range Scan**

- **인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식**
    - B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 인덱스 방식
- 대개 인덱스가 사용되는 실행계획을 보면 SQL에 문제가 없다고 판단할 수 있지만 실행계획 상에 Index Range Scan이 나타난다고 해서 항상 빠른 속도를 보장하는 것은 아니다.
- Index Range Scan이 가능하게 하려면 **인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 한다.**
- 인덱스를 스캔하는 범위(Range)를 얼마만큼 줄일 수 있느냐, 그리고 테이블로 액세스하는 횟수를 얼마만큼 줄일 수 있느냐가 관건이며, 이는 인덱스 설계와 SQL튜닝의 핵심 원리 중 하나

### 4. **클러스터드 인덱스와 넌클러스터드(secondary) 인덱스가 무엇인지 설명하세요.**

클러스터드 인덱스

- 테이블당 1개씩만 허용된다.
- 물리적으로 행을 재배열한다.
- PK설정 시 그 칼럼은 자동으로 클러스터드 인덱스가 만들어진다.
- 인덱스 자체의 리프 페이지가 곧 데이터이다. 즉 테이블 자체가 인덱스이다. (따로 인덱스 페이지를 만들지 않는다.)
- 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지한다.
- 비 클러스형 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력. 수정, 삭제는 느리다.
- 30% 이내에서 사용해야 좋은 선택도를 가진다.

넌 클러스터드 인덱스

- 테이블당 약 240개의 인덱스를 만들 수 있다.
- 인덱스 페이지는 로그파일에 저장된다.
- 레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다.
- 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 포인터(RID)이기 때문에 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력, 수정, 삭제는 더 빠르다.
- 인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지한다
- 3% 이내에서 사용해야 좋은 선택도를 가진다.

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-31-31.png)

### 5. Composite Index 에 대해 설명하세요.

- 인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것
- 주로 SQL 문장에서 WHERE절의 조건 컬럼이 2개 이상 AND로 연결되어 함께 사용되는 경우에 많이 사용
- 결합인덱스는 컬럼에 따른 데이터 분포도와 인덱스에 사용되는 컬럼의 순서에 따라서도 성능에 영향을 받는다.

고려할 사항

1. **조회조건에 항상 포함되는 경우**
    - 결합인덱스의 첫번째 컬럼이 조건에 사용되지 않으면 그 결합인덱스는 선택되지 않는다.
2. **첫번째 컬럼으로 최대한 많이 필터링을 할 수 있는 경우**
    - 결합인덱스의 첫번째 컬럼으로 처리 범위를 산정하기 때문에 최대한 많은 필터링을 처리하도록 결정하는 것이 좋다.
3. **'=' 조건으로 사용되는 경우**
    - 결합인덱스의 첫번째 컬럼이 '=' 조건이 아니라면 이후의 조건에서 '='을 사용하더라도 처리범위는 줄어들지 않는다.
    - '='이 아닌 조건을 사용하는 첫번째 컬럼의 경우 첫번째 컬럼만 인덱스를 타고(부분 인덱스), 이후의 컬럼은 인덱스를 타지 않는다.
4. **AND 조건으로 검색되는 경우**
    - 결합인덱스에 사용되는 복수의 컬럼이 AND 조건으로 검색되는 경우에 성능에 좋은 영향을 미친다. 하지만 OR로 사용되는 경우에는 결합인덱스를 사용하면 안된다.

## 5. 정규화

### 1. 정규화란 무엇인가요

**정규화는 어떤 배경에서 생겨났는가??**

- 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다.
- 중복된 정보로 인해 `갱신 이상`이 발생하게 된다.
- 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다.
- 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.

**정규화 개념**

- 정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미
- 자세히 말하면
    - 이상현상이 존재하는 테이블(릴레이션)을 분해하여 여러 개의 테이블(릴레이션)으로 생성하는 과정
    - **이상현상을 제거하기 위해 테이블을 분리하는 작업**
- 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 까지 있다 (보통 3정규형 까지 되어있으면 정규화 되었다고 한다)
- **정규화가 필요한 이유**
    - DB설계를 잘못 하면 불필요한 데이터 중복으로 인해 공간이 낭비되고 부작용을 초래할수있다.
    - 이러한 부작용을 이상(Anomaly)이라고 한다.
    - 삽입이상, 갱신이상, 삭제이상이 있다.

### 2. 정규화의 종류에 대해 설명해주세요

- 1 정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는 것 (도메인이 **원자값만** 포함)
- 2 정규화 : 기본키의 부분집합이 결정자가 안되도록 분리 (완전 함수적 종속)
- 3 정규화 : 이행종속 제거 (a → b, b → c 일때, a → c가 성립되는 것을 분리, 즉, a → b랑 b → c 로 테이블로 분리)
- BCNF : **값을 정하는 결정자가 후보키가 되도록 테이블 분해(모든 결정키가 후보키)**
- 이해가 어렵다면 [https://mangkyu.tistory.com/110](https://mangkyu.tistory.com/110) 다음을 참조.

### 3. 정규화의 장단점에 대해 설명해 주세요.

- 장점
    1. 데이터베이스 변경 시 이상 현상(Anomaly) 제거 위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다.
    2. 데이터베이스 구조 확장 시 재 디자인 최소화 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다.
    3. 사용자에게 데이터 모델을 더욱 의미있게 제공 정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.
- 단점
    1. 릴레이션 간의 연산이 많아질 수 있다. 
    2. = 함께 사용하는 테이블이 정규화로 인해 쪼개진다면 연산 할때마다 join문을 실행해야하므로 성능의 저하가 생길 수 있습니다. 이러한 경우에 역정규화를 실행합니다.

### 4. **정규화 이상 현상에 대해서 설명해 주세요.**

- 이상현상
    - 이상현상은 원하지 않는 값이 연쇄적으로 삭제되거나 수정 또는 삽입되는 현상입니다. 이상현상에는 갱신이상, 삽입이상, 삭제이상이 있습니다.
    - 삽입 이상 : 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 상황
    - 갱신 이상 : 전체의 데이터 중 일부만 변경하여 데이터가 불일치하는 상황
    - 삭제 이상 : 삭제로 인해 꼭 필요한 데이터까지 삭제되는 상황

## 6. 반정규화

### 1. 데이터베이스의 반정규화의 정의에 대해 설명해 주세요.

반정규화 정의

- 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다.
- 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.
- 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.
- 반정규화를 과도하게 적용하면 무결성이 깨질수있다.
- 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.

반정규화 대상

1. 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
3. 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

### 2. 비정규화란에 대해 설명해 주세요.

정의

- 정규화된 테이블(릴레이션)을 읽기성능 향상을 위해 테이블을 다시 합치는 방법

고려해야 할 점

1. **무결성(데이터의 정확성)이 떨어지는 것에 주의하자.**
    1. 데이터 중복이 발생해 나중에 데이터를 수정할 때 일부만 수정되어 결국 저장된 데이터가 정확하지 않을 수도 있다
2. **읽기(조회)속도는 빨라지지만 쓰기(삽입, 수정, 삭제)속도는 느려진다.**
    1. 이 문제도 중복된 데이터 사본때문이다. 그러니 쓰기 작업보다 읽기 작업의 성능이 중요할 때 고려하자.
3. **저장공간의 효율이 떨어지는 것에 주의하자.**
    1. 중복된 데이터의 공간 차지로 인해 데이터의 용량이 늘어난다.
4. **유지보수가 어렵다.**
    1. 테이블 자체가 크고 복잡하여 쉽게 수정할 수 없고 이로 인해 **확장성** 이 떨어진다.

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-32-13.png)

### 3. 역정규화란?

- 정규화된 테이블을비정규화 상태로 만들기 위한 **방법 중 하나**
- 데이터베이스의 **완벽한 구조설계를 포기**하고 데이터의 **무결성을 떨어트리는** 대신 관계형 데이터베이스의 **읽기(Read)성능 향상을 위한 설계** 방법이다.

## 7. 트랜잭션

### 1. 트랜잭션의 정의에 대해 설명하세요

- 트랜잭션은 작업의 **완전성**  을 보장해주는 것이다.
- 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.
- 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.
- 하나의 트랜잭션은 Commit 되거나 Rollback 된다
    - Commit 연산
        - 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.
    - Rollback 연산
        - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.
        - Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.
    
    ![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-33-33.png)
    
- 트랜잭션의 필요성
    - 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우
    - 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우
    - 위와 같은 상황이 발생되지 않도록 방지하기 위해, 즉, 트랜잭션의 성질인 ACID를 제공받기위해 트랜잭션을 사용한다.

### 2. 트랜잭션 특성(ACID)에 대해 설명하세요

- 원자성(Atomicity) : 트랜잭션이 DB에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다.
- 일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
- 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
- 지속성(Durability) : 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

### 3. 트랜잭션 상태에 대해 설명하세요.

트랜잭션의 연산을 수행할 때, 트랜잭션의 5가지 상태가 존재하며, 과정은 아래의 그림과 같다.

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-33-58.png)

**1. 활성화(Active)** **:** 트랜잭션이 작업을 시작하여 실행 중인 상태

**2. 실패(Failed) :** 트랜잭션에 오류가 발생하여 실행이 중단된 상태

**3. 철회(Aborted) :** 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

**4. 부분 완료(Partially commited) :** 트랜잭션의 마지막 연산까지 실행하고 commit 요청이 들어온 직후의 상태. 최종 결과를 데이터베이스에 아직 반영하지 않은 상태.

**5. 완료(Commited) :** 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

### 4. Locking 에 대해 설명하세요. 

- 추후 추가

### 5. 트랜잭션의 각 격리 수준에 대해서 설명하고, 각 수준에서 일어날 수 있는 문제에 대해 설명하세요.  

- 추후 추가

트랜잭션 격리 수준이란?

- 동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것.

**트랜잭션 격리 수준은 어떤게 있을까?** 

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

### 6. 데드락에 대해 설명해 주세요 

- 추후 추가

## 8. JOIN

### 1. **JOIN에 대해서 설명하세요.**

- 조인이란
    - **한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것**이다.
    - 따라서 조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.
    
    ```jsx
    SELECT *
    FROM city
    JOIN country ON city.CountryCode = country.Code;
    ```
    
    - 표준 SQL에서는 레코드를 조합하는 방식에 따라 JOIN을 다음과 같이 구분합니다.
        1. INNER JOIN
        2. LEFT JOIN
        3. RIGHT JOIN
- 조인의 필요성
    - 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고, 각 테이블끼리는 관계(Relationship)를 갖게 된다.
    - 이와 같은 특징으로 관계형 데이터베이스는 저장 공간의 효율성과 확장성이 향상되게 된다.
    - 다른 한편으로는 서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.

### 2. Inner JOIN, Outer JOIN, 에 대한 정의와 각 조인의 차이점에 대해서 설명해주세요

**1. INNER JOIN**

INNER JOIN은 ON 절과 함께 사용되며, ON 절의 조건을 만족하는 데이터만을 가져옵니다.

```sql
첫번째테이블이름
INNER JOIN 두번째테이블이름
ON 조건
두번째테이블이름
JOIN 두번째테이블이름
ON 조건
```

- ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있다.
- 표준 SQL과는 달리 MySQL에서는 JOIN, INNER JOIN, CROSS JOIN이 모두 같은 의미로 사용됨.
- 다음 예제는 Reservation 테이블의 Name 필드와 Customer 테이블의 Name 필드가 서로 일치하는 레코드만을 INNER JOIN으로 가져오는 예제

```sql
1. 
SELECT *
FROM Reservation
INNER JOIN Customer
ON Reservation.Name = Customer.Name;
2. 
SELECT *
FROM Reservation
JOIN Customer
ON Reservation.Name = Customer.Name;
```

MySQL에서는 위의 두 쿼리가 모두 같은 실행 결과를 보여준다. 

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-34-29.png)
**2. LEFT JOIN**

- LEFT JOIN은 첫 번째 테이블을 기준으로, 두 번째 테이블을 조합하는 JOIN이다.
- 이때 ON 절의 조건을 만족하지 않는 경우에는 첫 번째 테이블의 필드 값은 그대로 가져온다.
- 하지만 해당 레코드의 두 번째 테이블의 필드 값은 모두 NULL로 표시된다.
- ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있습니다.

```sql
첫번째테이블이름
LEFT JOIN 두번째테이블이름
ON 조건
```

- 다음 예제는 Reservation 테이블의 Name 필드를 기준으로 Customer 테이블의 Name 필드와 일치하는 레코드만을 LEFT JOIN으로 가져온 후, 그 중에서 ReserveDate 필드의 값이 2016년 02월 01일 이후인 레코드만을 선택하는 예제입니다.

```sql
SELECT *
FROM Reservation
LEFT JOIN Customer
ON Reservation.Name = Customer.Name
WHERE ReserveDate > '2016-02-01';
```

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-34-48.png)

- 위의 예제에서 두 개의 Name 값이 일치하면, INNER JOIN과 같이 두 테이블의 모든 필드를 그대로 가져옵니다.
- 하지만 두 개의 Name 값이 일치하지 않는 경우에는 Customer 테이블의 모든 필드를 NULL로 표시됩니다.

3. **RIGHT JOIN**

- RIGHT JOIN은 LEFT 조인과는 반대로 두 번째 테이블을 기준으로, 첫 번째 테이블을 조합하는 JOIN입니다.
- 이때 ON 절의 조건을 만족하지 않는 경우에는 두 번째 테이블의 필드 값은 그대로 가져옵니다.
- 하지만 해당 레코드의 첫 번째 테이블의 필드 값은 모두 NULL로 표시됩니다.
- ON 절에서는 WHERE 절에서 사용할 수 있는 모든 조건을 사용할 수 있습니다.

```sql
첫번째테이블이름
LEFT JOIN 두번째테이블이름
ON 조건
```

다음 예제는 Customer 테이블의 Name 필드를 기준으로 Reservation 테이블의 Name 필드와 일치하는 레코드만을 RIGHT JOIN으로 가져오는 예제입니다.

```sql
SELECT *
FROM Reservation
RIGHT JOIN Customer
ON Reservation.Name = Customer.Name;
```

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-35-15.png)

- 위의 예제에서 두 개의 Name 값이 일치하면, INNER JOIN과 같이 두 테이블의 모든 필드를 그대로 가져옵니다.
- 하지만 두 개의 Name 값이 일치하지 않는 경우에는 Reservation 테이블의 모든 필드를 NULL로 표시됩니다.

JOIN 요약

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-35-31.png)

![](./%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_1%EC%A3%BC%EC%B0%A8_White-Asher_img/2023-03-20-02-35-48.png)

## 9. VIEW

### 1. View의 정의에 대해 설명하세요.

- 추후 추가

## 10. Etc.

### 1. 데이터베이스에서 트리거와 프로시저의 차이점을 설명해주세요

- 추후 추가

출처

- [https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md#4-database](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md#4-database)
- [https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#정규화에-대해서](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EC%A0%95%EA%B7%9C%ED%99%94%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)
- [https://github.com/WooVictory/Ready-For-Tech-Interview/tree/master/Database](https://github.com/WooVictory/Ready-For-Tech-Interview/tree/master/Database)
- [https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md)
- [https://github.com/brave-people/brave-tech-interview/blob/main/contents/database.md](https://github.com/brave-people/brave-tech-interview/blob/main/contents/database.md)
- [https://github.com/ksundong/backend-interview-question](https://github.com/ksundong/backend-interview-question)
- [https://github.com/4z7l/tech_interview.zip/blob/main/직무/Database.md](https://github.com/4z7l/tech_interview.zip/blob/main/%EC%A7%81%EB%AC%B4/Database.md)
- [https://github.com/yoonje/developer-interview/blob/master/Database/README.md](https://github.com/yoonje/developer-interview/blob/master/Database/README.md)
- [https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Database.md](https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Database.md)
- [https://github.com/devham76/tech-interview-study/blob/master/contents/db.md](https://github.com/devham76/tech-interview-study/blob/master/contents/db.md)
- [https://github.com/SSAFY-CS-STUDY/Tech_interview/tree/main/02.database#database-답변](https://github.com/SSAFY-CS-STUDY/Tech_interview/tree/main/02.database#database-%EB%8B%B5%EB%B3%80)
- [https://rebro.kr/162](https://rebro.kr/162)
- [https://tecoble.techcourse.co.kr/post/2022-11-07-mysql-isolation/](https://tecoble.techcourse.co.kr/post/2022-11-07-mysql-isolation/)
- [http://www.tcpschool.com/mysql/mysql_multipleTable_join](http://www.tcpschool.com/mysql/mysql_multipleTable_join)
- [https://www.reddit.com/r/SQL/comments/aysflk/sql_join_chart_custom_poster_size/](https://www.reddit.com/r/SQL/comments/aysflk/sql_join_chart_custom_poster_size/)
- [https://dataschool.com/how-to-teach-people-sql/sql-join-types-explained-visually/](https://dataschool.com/how-to-teach-people-sql/sql-join-types-explained-visually/)